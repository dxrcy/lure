#! -- Provided by runtime --
#!
#! These functions will not be written in Lure, but they will be exposed to
#! `std`, or possibly any module.
#!
#! Only shown here for documentation purposes.

#: int -> never
func exit(code) end

#: any -> string
func type_of(value) end

#: path, int -> { int, int }
func open(path, mode) end

#: int -> int
func close(file_handle) end

#: int, string -> int
func write(file_handle, text) end

#: int -> { int, string }
func read(file_handle, length) end

#: int -> { int, string }
func read_line(file_handle) end

# TODO: idk what to do for files...

#: int
let stdout = 0
#: int
let stdin = 1
#: int
let stderr = 2

#: any -> int
func len(arg)
    # Something like:
    match type_of(arg)
        case "nil"    then return 0
        case "bool"   then return 0
        case "number" then return 0
        case "char"   then return 1
        case "string" then todo() end
        case "table" then
            if arg.@len /= nil
                then return arg.@len()
                else todo()
            end
    end
end

#: any -> string
func to_string(arg)
    # Something like:
    match type_of(arg)
        case "nil"    then return "nil"
        case "number" then todo()
        case "char"   then todo()
        case "string" then return arg
        case "bool" then
            if arg 
                then return "true"
                else return "false"
            end
        case "table" then
            if arg.@to_string /= nil
                then return arg.@to_string()
                else todo() # Something like `<type@line>`
            end
    end
end

#: { k:v }, k -> v
func get(arg, index)
    # Something like:
    match type_of(arg)
        case "string" then todo()
        case "table" then
            if arg.@get /= nil
                then return arg.@get(index)
                else todo()
            end
        else panic()
    end
end

#: { int:v }, int, int -> v
func slice(arg, start, end)
    # Something like:
    match type_of(arg)
        case "string" then todo()
        case "table" then
            if arg.@slice /= nil
                then return arg.@slice(start, end)
                else todo()
            end
        else panic()
    end
end

#: { k:v }, k, v -> void
func set(arg, index, value)
    # Something like:
    match type_of(arg)
        case "string" then todo()
        case "table" then
            if arg.@get /= nil
                then return arg.@set(index, value)
                else todo()
            end
        else panic()
    end
end

# Returns:
#   -1 if value < other
#    0 if value == other
#   +1 if value > other
#: a, a -> int
func compare(value, other)
    # Something like:
    match { type_of(value), type_of(other) }
        case { "null", "null" }     then return 0
        case { "bool", "bool" }     then todo()
        case { "number", "number" } then todo() # Near-enough floats should return 0
        case { "char", "char" }     then todo()
        case { "string", "string" } then todo()
        case { "char", "string" }   then todo() 
        case { "string", "char" }   then todo() 
        case { "table", "table" } then
            if value.@compare /= nil
                then return value.@compare(other)
                else todo() # Maybe just return non-zero always ?
            end
        else return false # Mismatched types
    end
end

# Used by the `+` operator
#: a, a -> a
func add(value, other) end

#: number -> int
func floor(value) end

# Random float in the range [0, 1)
#: void -> int
func random() end

