#!/bin/lure

# A file is a module
# Modules can only contain 'items':
#   let|func|template|module
#
# Note that a `let` variable in a module acts as a constant

# Main function is required for `main.lur`

# Implicit imports for every file/module
let std = require("@std") # Or "std"
let { print, println, #(...) } = std.prelude

# Import a module
let lib = require("lib")
let add = lib.add

# (implicit type signature)
# Either one of:
#: void -> int|nil
#: {string} -> int|nil
func main()
    print("Hello World")

    # All variables and items are scoped by block
    
    let x = 2
    x = x + 3
    x += 3 # Advanced assignment operators are supported
    print(x)

    # Re-declaration of variable shadows original
    let x = 4

    if x > 3 then
        print("> 3")
    elif x == 2 then
        print("== 2")
    else
        print("<= 3")
    end
    # (Alternative formatting)
    if x > 3
        then print("> 3")
        else print("<= 3")
    end

    # Hopefully this can work
    let y = if x > 3
        then 4
        else 6
    end

    let s = "abc"
    print(s)
    let s2 = s & "def" # Concatenation operator is undecided (cannot use `..`)
    s &= "def"
    print(s, s2)

    # Traditional C-style for-loop ??
    # for let i = 0, i < 10, i += 1 do
    #     print(i) # 0, 1, ... 9
    # end

    # Simple range for-loop
    for i in 0 to 10 do
        print(i) # 0, 1, ... 9
    end
    for i in 0 to len(list) do
        printf("{}: {}\n", i, list[i])
    end

    let list = { 4, 5, 6 }

    print(len(list))

    for i in list do
        printf("{}: {}\n", i, item) # 0: 4, 1: 5, 2: 6
    end
    for i, item in list do
        printf("{}: {}\n", i, item) # 0: 4, 1: 5, 2: 6
    end
    for _, item in list do
        printf("{}\n", item) # 4, 5, 6
    end
    # ^ Underscore is used to ignore a value
    # ^ Comma *may* be removed between values in this context?

    let dict = {
        a = 1,
        b = 2,
    }

    for key in dict do
        printf("{}: {}\n", key, dict[key]) # a: 1, b: 2
    end
    for key, value in dict do
        printf("{}: {}\n", key, value) # a: 1, b: 2
    end
    for _, value in dict do
        printf("{}\n", value) # 1 2
    end

    let mixed = {
        4,
        a = 5,
    }

    for key in mixed do
        printf("{}: {}\n", key, mixed[key]) # 0: 4, a: 5
    end
    for key, value in mixed do
        printf("{}: {}\n", key, value) # 0: 4, a: 5
    end
    for _, value in mixed do
        printf("{}\n", value) # 4, 5
    end

    let a = 0
    while a < 10 do
        print(a)
        a += 1
    end

    let a = 0
    while a do
        print(a)
        a += 1
        if a > 10 then
            break
        end
    end

    print(add(5, 6))
    print(lib.add(5, 6))

    print(lib.PI)

    let john = as lib.Person {
        name = "John",
        age = 30,
    }

    assert(typeof(nil),    "nil")
    assert(typeof(true),   "bool")
    assert(typeof(4),      "number")
    assert(typeof(4.5),    "number")
    assert(typeof('f'),    "char")
    assert(typeof("foo"),  "string")
    assert(typeof(list),   "table")
    assert(typeof(dict),   "table")
    assert(typeof(mixed),  "table")
    assert(typeof(john),   "table") # template "person" is no longer relevant

    # A template is used as a value. Not allowed.
    # Interpreter will throw an error
    assert(typeof(person), "never")
    
    # This also *might* throw an error?
    assert(typeof(lib),    "never")

    # Spread operator
    let jane = { name = "Jane", ..john }

    # Destructuring
    let { name } = { name = "John" }
    let { name, age } = john
    let { name, .. } = john
    # Renaming fields
    let { name = johns_name } = john
    print(johns_name)
    # No! Not allowed.
    let { name, _ } = john
    # Completely pointless. Use `_` instead. Throws error.
    let { .. } = john
    # Omitting a field
    # Still works, but best to write `..` for readability
    # Actually ideally fields are checked when using a template.
    # ^ Maybe a job for the linter ?
    let { name } = john
    # Positional destructuring
    # Not the nicest syntax, but avoids ambiguity
    let { 0 = a, 1 = b } = { 3, 4 }

    # Match (switch) statements
    let x = 3
    # As a statement
    match x
        case 4 then
            print("4")
        case 5 then
            print("5")
            print("it is five")
        else
            "default"
    end

    # Similar to `if` as an expression (ideally)
    let y = match x
        case 4 then "4"
        case 5 then "5"
        else "default"
    end

    # Match guards
    # Maybe use `if` instead of `where` if possible
    let foo = 9
    let y = match x
        case 4 where foo == 9 then
            "4 and foo == 9"
        case 4 then
            "4 but foo != 9"
        case 5 then
            "5"
        else
            "default"
    end

    # Matching a table
    match john
        case { name = "John", .. } then
            print("Hello John")
        else
            print("Who are you")
    end
end


