#!/bin/lure

# A file is a module
# A module contains statements
# A statement can be:
# - function
# - template
# - another module
# - variable declaration
# - assignment operation
# - loop / conditional / match
# - expression (incl. function call)

# NO statements/functions are hoisted

# Implicit imports for every file/module
let std = require("@std") # Or "std"
let { print, println, (...) } = std.prelude

# Import a module
# Executes module when `require` expression is run
# This will run any module-level statements
let lib = require("lib")
let add = lib.add

println("Hello World")

# All variables and items are scoped by block

let x = 2
x = x + 3 # Advanced assignment operators are NOT supported
println(x)

# Re-declaration of variable shadows original
let x = 4

if x > 3 then
    println("> 3")
elif x == 2 then
    println("== 2")
else
    println("<= 3")
end
# (Alternative formatting)
if x > 3
    then println("> 3")
    else println("<= 3")
end

# Hopefully this can work
let y = if x > 3
    then 4
    else 6
end

let s = "abc"
log(s)
let s2 = s & "def" # Concatenation operator is undecided (cannot use `..`)
println(s, s2)

# Simple range for-loop
for i in 0 to 10 do
    log(i) # 0, 1, ... 9
end
for i in 0 to len(list) do
    println("{}: {}\n", i, list[i])
end

let list = { 4, 5, 6 }

println(len(list))

# Maybe use different syntax to comma separated idents
for i in list do
    println("{}: {}\n", i, item) # 0: 4, 1: 5, 2: 6
end
for i, item in list do
    println("{}: {}\n", i, item) # 0: 4, 1: 5, 2: 6
end
for _, item in list do
    println("{}\n", item) # 4, 5, 6
end
# ^ Underscore is used to ignore a value

let dict = {
    a = 1,
    b = 2,
}

for key in dict do
    println("{}: {}\n", key, dict[key]) # a: 1, b: 2
end
for key, value in dict do
    println("{}: {}\n", key, value) # a: 1, b: 2
end
for _, value in dict do
    println("{}\n", value) # 1 2
end

let mixed = {
    4,
    a = 5,
}

for key in mixed do
    println("{}: {}\n", key, mixed[key]) # 0: 4, a: 5
end
for key, value in mixed do
    println("{}: {}\n", key, value) # 0: 4, a: 5
end
for _, value in mixed do
    println("{}\n", value) # 4, 5
end

let a = 0
while a < 10 do
    log(a)
    a = a + 1
end

let a = 0
while a do
    log(a)
    a = a + 1
    if a > 10 then
        break
    end
end

log(add(5, 6))
log(lib.add(5, 6))

log(lib.PI)

# Maybe change keyword `as` for templates ?
let john = as lib.Person {
    name = "John",
    age = 30,
}

assert(type_of(nil),   "nil")
assert(type_of(true),  "bool")
assert(type_of(4),     "number")
assert(type_of(4.5),   "number")
assert(type_of('f'),   "char")
assert(type_of("foo"), "string")
assert(type_of(list),  "table")
assert(type_of(dict),  "table")
assert(type_of(mixed), "table")
assert(type_of(john),  "table") # template "person" is no longer relevant

# A template is used as a value. Not allowed.
# Interpreter will throw an error when checking if variables are declared
assert(type_of(person), "never")

# This also *might* throw an error?
# Unless modules are converted to tables
assert(type_of(lib), "never")

# Indexing and slicing
# Works the same for strings and lists
let a = "abcdef"
assert(a[0], "a")
assert(a[-1], "f")
assert(a[1, 2], "ab")
assert(a[0, -1], "abcdef")
assert(a[1, -1], "bcdef")
assert(a[0, -2], "abcde")
# Syntax sugar for call to core method implementations
assert(a[0], a.get(0, nil))
assert(a[-1], a.get(-1, nil))
assert(a[1, 2], a.slice(1, 2))
assert(a[0, -1], a.slice(0, -1))
a[0] = "A"
a.set(0, "A")
# Panic if type is not table or string
let n = 123
n[0]
n[0, 3]
n[0] = 5
n.get(0)
n.slice(0, 3)
n.set(0, 5)
# Named table access
let b = { a = 1, b = 2 }
assert(b.a, 1)
assert(b.b, 2)
assert(b["a"], 1)
assert(b[0], nil)
assert(b[0, 1], nil)

# Spread operator
let jane = { name = "Jane", ..john }

# Destructuring
let { name = name } = { name = "John" }
let { name = name, age = age } = john
let { name = name, .. } = john
# Renaming fields
let { name = johns_name } = john
println(johns_name)
# No! Not allowed.
let { name = name, _ } = john
# Completely pointless. Use `_` instead. Throws error.
let { .. } = john
# Omitting a field
# Still works, but best to write `..` for readability
# Actually ideally fields are checked when using a template.
# ^ Maybe a job for the linter ?
let { name = name } = john
# Positional destructuring
let { a, b } = { 3, 4 }

# Match (switch) statements
# Case can be any expression which will be compared with `std.compare`
let x = 3
# As a statement
match x
    case 4 then
        println("4")
    case 5 then
        println("5")
        println("it is five")
    else
        println("default")
end

# Similar to `if` as an expression (ideally)
let y = match x
    case 4 then "4"
    case 5 then "5"
    else "default"
end

# Match guards
let foo = 9
let y = match x
    case 4 if foo == 9 then
        "4 and foo == 9"
    case 4 then
        "4 but foo != 9"
    case 5 then
        "5"
    else
        "default"
end

# Matching a table
match john
    case { name = "John", .. } then
        println("Hello John")
    else
        println("Who are you")
end


