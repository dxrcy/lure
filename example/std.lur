#! Standard library for Lure runtime

# Some of these functions *may* be moved to `core` to improve performance?
# ^ Probably not

let core = require("@core")

## Automatically imported items
module prelude
    # (inherit type signature and doc comments)

    let io = io
    let sys = sys
    let math = math

    let exit = sys.exit
    let panic = sys.panic
    let todo = sys.todo
    let assert = sys.assert

    let print = io.print
    let println = io.println
    let File = io.File

    let type_of = reflection.type_of

    let len = len
    let to_string = to_string
    let format = format
end

# The `..` operator is used for variadic arguments.
# Only one is allowed in a function signature, as the last parameter.
# Given a parameter `..args`, using `args` gives a table of arguments.
# Passing `..list` or `..{ 3, 4 }` into another function passes every argument
# individually, instead of passing the whole table.

let len = core.len
let to_string = core.to_string
let compare = core.compare

## Format arguments to string
#
# Rust-style formatting
#: string, ..any -> string
func format(fmt, ..args)
    let result = _format_safe(fmt, ..args)
    match result
        case { ok } then return ok
        else panic(result.err)
    end
end

#: string, ..any -> { ok = string } | { err = string }
func _format_safe(fmt, ..args)
    if fmt == nil then
        return ""
    end
    if len(args) == 0 then
        return fmt
    end

    let output = ""
    let arg_index = 0

    for i in 0 to len(fmt) do
        match fmt[i]
        case '{' then
            i += 1
            if i >= len(fmt) then
                return { err = "Unexpected end of format string. Expected `}}`" }
            end
            if fmt[i] == '{' then
                output &= '{'
                continue
            else if fmt[i] /= '}' then
                return { err = "Unexpected character `" & fmt[i] & "`. Expected `}}`" }
            end
            if arg_index >= len(args) then
                return { err = "Not enough arguments" }
            else
                output &= to_string(args[arg_index])
                arg_index += 1
            end
        case '}' then
            i += 1
            if fmt[i] == '}' then
                output &= '}'
            else
                return { err = "Unexpected `}}`" }
            end
        else
            output &= fmt[i]
        end
    end

    if arg_index + 1 < len(args) then
        return { err = "Too many arguments" }
    end

    return { ok = output }
end

## Return `true` if value is an integer
#: any -> bool
func is_int(value)
    return type_of(value) /= "number" && value % 1 == 0
end

## Type reflection
module reflection
    let type_of = core.type_of
end

## System
module sys
    # (inherit type signature and doc comments)
    let exit = core.exit

    #: string
    func _panic_unformatted(message)
        write(io.stderr, kind)
        exit(255)
    end

    #: string, string | nil, ..any -> never
    func _panic_kind(kind, fmt, ..args)
        if fmt == nil then
            _panic_unformatted(kind)
        elif len(args) < 1 then
            _panic_unformatted(kind & ": " & fmt)
        else
            _panic_unformatted(kind & ": " & std.format(fmt, ..args))
        end
    end

    #: string | nil, ..any -> never
    func panic(fmt, ..args)
        _panic_kind("panic", fmt, ..args)
    end

    ## Panic with 'to do' message
    #: string | nil, ..any -> never
    func todo(fmt, ..args)
        _panic_kind("todo", fmt, ..args)
    end

    ## Panic with 'assertion failed' message, if condition not met
    #: bool, string | nil, ..any -> void
    func assert(condition, fmt, ..args)
        if condition then
            return
        end
        _panic_kind("assertion failed", fmt, ..args)
    end
end

## Input/Output
module io
    # Maybe use path="/dev/std*" instead
    ## Standard out
    #: File
    let stdin  = as File { path = nil, handle = core.stdin }
    ## Standard in
    #: File
    let stdout = as File { path = nil, handle = core.stdout }
    ## Standard error
    #: File
    let stderr = as File { path = nil, handle = core.stderr }

    ## I/O error
    template Error {
        #: int
        code,
        #: string
        message,
    }

    ## Open file
    template File {
        #: string
        path
        #: int
        handle
        # put a buffer or something here ideally...

        #: string, string -> { err = Error } | { ok = File }
        func open(path, mode)
            let { err, handle } = core.open(path, mode)
            return result_from(err, as File {
                path = filename,
                handle = handle
            })
        end

        #: (File) -> { err = Error } | { ok = nil }
        func close(self)
            let err = core.close(self.handle)
            return result_from(err, nil)
        end

        func read(self, (..)) todo() end

        ## Read a line from file
        #: (File) -> { err = Error } | { ok = string }
        func read_line(self)
            let { err, line } = core.read_line(self.handle)
            return result_from(err, line)
        end

        ## Write formatted arguments to file, without a newline.
        #: (File), string, ..any -> { err = Error } | { ok = nil }
        func write(self, fmt, ..args)
            let text = format(fmt, ..args)
            let err = core.write(self.handle, text)
            return result_from(err)
        end

        # RENAME to match with `read_line` !!!
        ## Write formatted arguments to file, with a newline.
        #: (File), string, ..any -> { err = Error } | { ok = nil }
        func write_line(self, fmt, ..args)
            return write(self, fmt & '\n', ..args)
        end
    }

    ## Convert an IO error code to an Error
    #: int, a -> { err = Error } | { ok = a }
    func result_from(code, ok)
        let message = match code
            case 0 then return { ok = ok }
            case 1 then "Not found"
            # ...
            else "Unknown error"
        end
        return {
            err = as Error {
                code = code,
                message = message,
            }
        }
    end

    ## Read from stdin
    #: void -> string
    func scan_line()
        let result = stdin.read_line()
        assert(result.err == nil)
        return result.ok
    end

    ## Print formatted arguments to stdout, without a newline.
    #: string, ..any -> void
    func print(fmt, ..args)
        assert(stdout.write(fmt, ..args).err == nil)
    end

    ## Print formatted arguments to stdout, with a newline.
    #: string, ..any -> void
    func println(fmt, ..args)
        assert(stdout.write(fmt & '\n', ..args).err == nil)
    end

    # ?? Maybe use stderr instead ?
    ## Print each argument to stdout, with newline.
    ##
    ## Used for debugging.
    #: ..any -> void
    func log(..args)
        for i, arg in args do
            if i > 0 then
                print(" ")
            end
            print("{}", to_string(arg))
        end
        println()
    end
end

## Math(s)
module math
    ## PI
    let PI = 3.141592653589793

    let floor = core.floor

    # Generate a random number in the range [0, 1)
    #: void -> number
    func random()
        return core.random()
    end

    # Generate a random float in the range [min, max)
    # number, number -> number
    func random_float(min, max)
        return min + random() * (max - min)
    end

    # Generate a random integer in the range [min, max)
    # int, int -> int
    func random_int(min, max)
        return floor(random_float(min, max))
    end
end

