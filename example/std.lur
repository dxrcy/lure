#! Standard library for Lure runtime

# Some of these functions *may* be moved to `core` to improve performance?

# Maybe importing "@core" from outside of `std` causes a warning?
let core = require("@core")

## Automatically imported items
module prelude
    # (inherit type signature and doc comments)

    let exit = sys.exit
    let panic = sys.panic
    let todo = sys.todo
    let assert = sys.assert

    let print = io.print
    let printf = io.printf

    let typeof = reflection.typeof

    let len = len
    let to_string = to_string
    let format = format
end

# The `..` operator is used for variadic arguments.
# Only one is allowed in a function signature, as the last parameter.
# Given a parameter `..args`, using `args` gives a table of arguments.
# Passing `..list` or `..{ 3, 4 }` into another function passes every argument
# individually, instead of passing the whole table.

let len = core.len
let to_string = core.to_string

## Format arguments to string
#
# Rust-style formatting
#: string, ..any -> string
func format(fmt, ..args)
    if fmt == nil then
        return ""
    end
    if len(args) == 0 then
        return fmt
    end

    todo()
end

## Return `true` if value is an integer
#: any -> bool
func is_int(value)
    return typeof(value) /= "number" && value % 1 == 0
end

## Type reflection
module reflection
    let typeof = core.typeof
end

## System
module sys
    # (inherit type signature and doc comments)
    let exit = core.exit

    func panic(..message)
        if len(message) == 0 then
            core.panic("panic")
        else
            core.panic("panic:", std.format(..message))
        end
    end

    ## Panic with 'to do' message
    #: ..any -> never
    func todo(..message)
        if len(message) > 0 then
            panic("to do:", ..message)
        else
            panic("to do")
        end
    end

    ## Panic with 'assertion failed' message, if condition not met
    #: bool -> void
    func assert(condition, ..message)
        if condition then
            return
        end
        if len(message) > 0 then
            panic("assertion failed:", ..message)
        else
            panic("assertion failed")
        end
    end
end

## Input/Output
module io
    # Maybe use path="/dev/std*" instead
    ## Standard out
    #: File
    let stdin  = as File { path = nil, handle = core.stdin }
    ## Standard in
    #: File
    let stdout = as File { path = nil, handle = core.stdout }
    ## Standard error
    #: File
    let stderr = as File { path = nil, handle = core.stderr }

    ## Open file
    template File {
        #: string
        path
        #: int
        handle
        # a buffer or something ideally...

        #: (File) -> Error|nil
        func close(self)
            let err = core.close(self.handle)
            return result_from(err)
        end

        #: (File) -> Error|nil, string|nil
        func read_line(self)
            let err, line = core.read_line(self.handle)
            if err == nil then
                return result_from(err), nil
            end
            return nil, line
        end
    }

    ## I/O error
    template Error {
        #: int
        code,
        #: string
        message,
    }

    # Move to `Error.from`
    ## Convert an error code to an Error
    #: int -> Error|nil
    func result_from(code)
        let message = match code
            case 0 then return nil
            case 1 then "Not found"
            # ...
            else "Unknown error"
        end
        return as Error {
            code = code,
            message = message,
        }
    end

    #: string, string -> Error|nil, File|nil
    func open(path, mode)
        let err, handle = core.open(path, mode)
        if err /= nil then
            return result_from(err), nil
        end
        return nil, as File {
            path = filename,
            handle = handle
        }
    end

    ## Write formatted arguments to file, without a newline.
    #: File, string, ..any -> Error|nil
    func write(file, fmt, ..args)
        let text = format(fmt, ..args)
        let err = core.write(file.handle, text)
        return result_from(err)
    end

    ## Write formatted arguments to file, with a newline.
    #: File, string, ..any -> void
    func writeln(file, fmt, ..args)
        return write(file, fmt & '\n', ..args)
    end
    ## Print formatted arguments to stdout, without a newline.
    #: string, ..any -> void
    func print(fmt, ..args)
        _ = write(stdout, fmt, ..args)
    end
    ## Print formatted arguments to stdout, with a newline.
    #: string, ..any -> void
    func println(fmt, ..args)
        _ = write(file, fmt & '\n', ..args)
    end

    ## Print each argument to stderr, with newline.
    ##
    ## Used for debugging.
    #: ..any -> void
    func log(..args)
        for i, arg in args do
            if i > 0 then
                write(stderr, " ")
            end
            write(stderr, "{}", to_string(arg))
        end
        write(stderr, "\n")
    end
end

## Math(s)
module math
    ## PI
    let PI = 3.141592653589793
end

